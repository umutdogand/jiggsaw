<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Jigsaw Puzzle for My Love</title>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background-color: #f7f2f2;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  h1 {
    color: #d6336c;
    margin: 20px;
    text-align: center;
  }
  canvas {
    border: 2px solid #d6336c;
    margin-top: 10px;
    touch-action: none;
    max-width: 95vw;
    max-height: 75vh;
    display: block;
  }
  #upload, #reset {
    margin: 10px;
  }
</style>
</head>
<body>

<h1>Jigsaw Puzzle for My Love ðŸ’–</h1>
<input type="file" id="upload" accept="image/*" />
<button id="reset">Reset Puzzle</button>
<br />
<canvas id="puzzleCanvas"></canvas>

<script>
const canvas = document.getElementById('puzzleCanvas');
let ctx;

const upload = document.getElementById('upload');
const reset = document.getElementById('reset');

let img = new Image();
let pieces = [];
const rows = 5;
const cols = 10;
let pieceWidth, pieceHeight;
let imgX, imgY, imgW, imgH;

let draggingPiece = null;
let draggingGroup = null;
let offsetX = 0;
let offsetY = 0;
let groupIdCounter = 0;

const overlapRatio = 0.25;
const snapAudio = new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg');
function playSnapSound() {
  snapAudio.currentTime = 0;
  snapAudio.play();
}

let overlap;
let desiredWidth;
let desiredHeight;

function setupHiDPICanvas(canvas, desiredWidth, desiredHeight) {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = desiredWidth * dpr;
  canvas.height = desiredHeight * dpr;
  canvas.style.width = desiredWidth + 'px';
  canvas.style.height = desiredHeight + 'px';

  const ctx = canvas.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr, dpr);
  return ctx;
}

function resizeCanvas() {
  desiredWidth = Math.min(window.innerWidth * 0.95, 1000);
  desiredHeight = Math.min(window.innerHeight * 0.75, 800);
  ctx = setupHiDPICanvas(canvas, desiredWidth, desiredHeight);

  if (img.complete && img.naturalWidth) {
    setupPuzzle();
  }
}

// Setup puzzle pieces and positions based on current canvas size
function setupPuzzle() {
  const maxW = desiredWidth * 0.8;
  const maxH = desiredHeight * 0.8;
  const ratio = Math.min(maxW / img.width, maxH / img.height);
  imgW = img.width * ratio;
  imgH = img.height * ratio;
  imgX = (desiredWidth - imgW) / 2;
  imgY = (desiredHeight - imgH) / 2;

  pieceWidth = imgW / cols;
  pieceHeight = imgH / rows;
  overlap = Math.min(pieceWidth, pieceHeight) * overlapRatio;

  pieces = [];
  groupIdCounter = 0;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const shape = {
        top: y === 0 ? 0 : (Math.random() > 0.5 ? 1 : -1),
        right: x === cols - 1 ? 0 : (Math.random() > 0.5 ? 1 : -1),
        bottom: y === rows - 1 ? 0 : (Math.random() > 0.5 ? 1 : -1),
        left: x === 0 ? 0 : null
      };
      if (x > 0) shape.left = -pieces[pieces.length - 1].shape.right;
      if (y > 0) shape.top = -pieces[(y - 1) * cols + x].shape.bottom;

      const pos = getRandomPositionOutsideImage(overlap);

      pieces.push({
        sx: x * (img.width / cols),
        sy: y * (img.height / rows),
        x: pos.x,
        y: pos.y,
        homeX: imgX + x * pieceWidth,
        homeY: imgY + y * pieceHeight,
        shape: shape,
        placed: false,
        gridX: x,
        gridY: y,
        group: groupIdCounter++
      });
    }
  }
  draw();
}

function getRandomPositionOutsideImage(overlap) {
  const side = Math.floor(Math.random() * 4);
  let x, y;

  if (side === 0) {
    // Above image
    x = Math.random() * (imgX + imgW - pieceWidth) + imgX - overlap;
    y = Math.random() * (imgY - pieceHeight - overlap) + overlap / 2;
  } else if (side === 1) {
    // Below image
    x = Math.random() * (imgX + imgW - pieceWidth) + imgX - overlap;
    y = imgY + imgH + Math.random() * (desiredHeight - (imgY + imgH) - pieceHeight) + overlap / 2;
  } else if (side === 2) {
    // Left of image
    x = Math.random() * (imgX - pieceWidth - overlap) + overlap / 2;
    y = Math.random() * (desiredHeight - pieceHeight);
  } else {
    // Right of image
    x = imgX + imgW + Math.random() * (desiredWidth - (imgX + imgW) - pieceWidth) + overlap / 2;
    y = Math.random() * (desiredHeight - pieceHeight);
  }
  return { x, y };
}

function draw() {
  ctx.clearRect(0, 0, desiredWidth, desiredHeight);

  // Draw faint background image
  ctx.globalAlpha = 0.2;
  ctx.drawImage(img, 0, 0, img.width, img.height, imgX, imgY, imgW, imgH);
  ctx.globalAlpha = 1;

  pieces.forEach(p => {
    ctx.save();
    ctx.beginPath();
    createPiecePath(p, p.x + overlap, p.y + overlap);
    ctx.clip();

    const scaleX = img.width / imgW;
    const scaleY = img.height / imgH;

    ctx.drawImage(
      img,
      p.sx - overlap * scaleX,
      p.sy - overlap * scaleY,
      img.width / cols + 2 * overlap * scaleX,
      img.height / rows + 2 * overlap * scaleY,
      p.x,
      p.y,
      pieceWidth + 2 * overlap,
      pieceHeight + 2 * overlap
    );

    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  });
}

function createPiecePath(p, x, y) {
  const size = Math.min(pieceWidth, pieceHeight) * overlapRatio;
  ctx.moveTo(x, y);

  // Top edge
  if (p.shape.top === 0) {
    ctx.lineTo(x + pieceWidth, y);
  } else {
    const dir = p.shape.top;
    ctx.lineTo(x + pieceWidth / 3, y);
    ctx.bezierCurveTo(
      x + pieceWidth / 3, y - size * dir,
      x + 2 * pieceWidth / 3, y - size * dir,
      x + 2 * pieceWidth / 3, y
    );
    ctx.lineTo(x + pieceWidth, y);
  }

  // Right edge
  if (p.shape.right === 0) {
    ctx.lineTo(x + pieceWidth, y + pieceHeight);
  } else {
    const dir = p.shape.right;
    ctx.lineTo(x + pieceWidth, y + pieceHeight / 3);
    ctx.bezierCurveTo(
      x + pieceWidth + size * dir, y + pieceHeight / 3,
      x + pieceWidth + size * dir, y + 2 * pieceHeight / 3,
      x + pieceWidth, y + 2 * pieceHeight / 3
    );
    ctx.lineTo(x + pieceWidth, y + pieceHeight);
  }

  // Bottom edge
  if (p.shape.bottom === 0) {
    ctx.lineTo(x, y + pieceHeight);
  } else {
    const dir = p.shape.bottom;
    ctx.lineTo(x + 2 * pieceWidth / 3, y + pieceHeight);
    ctx.bezierCurveTo(
      x + 2 * pieceWidth / 3, y + pieceHeight + size * dir,
      x + pieceWidth / 3, y + pieceHeight + size * dir,
      x + pieceWidth / 3, y + pieceHeight
    );
    ctx.lineTo(x, y + pieceHeight);
  }

  // Left edge
  if (p.shape.left === 0) {
    ctx.lineTo(x, y);
  } else {
    const dir = p.shape.left;
    ctx.lineTo(x, y + 2 * pieceHeight / 3);
    ctx.bezierCurveTo(
      x - size * dir, y + 2 * pieceHeight / 3,
      x - size * dir, y + pieceHeight / 3,
      x, y + pieceHeight / 3
    );
    ctx.lineTo(x, y);
  }
  ctx.closePath();
}

function pointInPiece(p, mx, my) {
  ctx.beginPath();
  createPiecePath(p, p.x + overlap, p.y + overlap);
  return ctx.isPointInPath(mx, my);
}

function findPieceAt(mx, my) {
  for (let i = pieces.length - 1; i >= 0; i--) {
    if (pointInPiece(pieces[i], mx, my)) {
      return pieces[i];
    }
  }
  return null;
}

function onPointerDown(e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX || e.touches[0].clientX) - rect.left;
  const my = (e.clientY || e.touches[0].clientY) - rect.top;

  const p = findPieceAt(mx, my);
  if (p) {
    draggingGroup = p.group;
    draggingPiece = pieces.filter(pc => pc.group === draggingGroup);

    offsetX = mx - draggingPiece[0].x;
    offsetY = my - draggingPiece[0].y;

    // Bring group to front
    pieces = pieces.filter(pc => pc.group !== draggingGroup).concat(draggingPiece);
  }
}

function onPointerMove(e) {
  if (!draggingPiece) return;
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX || e.touches[0].clientX) - rect.left;
  const my = (e.clientY || e.touches[0].clientY) - rect.top;

  const dx = mx - offsetX;
  const dy = my - offsetY;

  // Move all pieces in group together
  draggingPiece.forEach(p => {
    p.x += dx - p.x + p.x; // corrected below:
  });

  // Correction: we want to move all pieces by delta (dx - previous x of draggingPiece[0])
  const deltaX = dx - draggingPiece[0].x;
  const deltaY = dy - draggingPiece[0].y;
  draggingPiece.forEach(p => {
    p.x += deltaX;
    p.y += deltaY;
  });

  draw();
}

function onPointerUp(e) {
  if (!draggingPiece) return;
  e.preventDefault();

  // Check for snapping pieces in groups
  let anySnapped = false;
  draggingPiece.forEach(p => {
    if (p.placed) return; // already placed

    const neighbors = getNeighbors(p);
    neighbors.forEach(n => {
      if (n.group === p.group) return; // same group already
      if (isClose(p, n)) {
        // Snap n to p and join groups
        joinGroups(p, n);
        anySnapped = true;
        playSnapSound();
      }
    });
  });

  // Check if all placed
  if (pieces.every(p => p.placed)) {
    setTimeout(() => alert('Congratulations! Puzzle solved! ðŸŽ‰'), 100);
  }

  draggingPiece = null;
  draggingGroup = null;
  draw();
}

function getNeighbors(piece) {
  const neighbors = [];
  const directions = [
    {dx: 0, dy: -1, side: 'top', oppSide: 'bottom'},
    {dx: 1, dy: 0, side: 'right', oppSide: 'left'},
    {dx: 0, dy: 1, side: 'bottom', oppSide: 'top'},
    {dx: -1, dy: 0, side: 'left', oppSide: 'right'}
  ];
  directions.forEach(d => {
    const nx = piece.gridX + d.dx;
    const ny = piece.gridY + d.dy;
    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
      const neighbor = pieces.find(p => p.gridX === nx && p.gridY === ny);
      if (neighbor) neighbors.push(neighbor);
    }
  });
  return neighbors;
}

function isClose(p1, p2) {
  const dx = p1.x - p2.x + (p1.gridX - p2.gridX) * pieceWidth;
  const dy = p1.y - p2.y + (p1.gridY - p2.gridY) * pieceHeight;
  const dist = Math.sqrt(dx * dx + dy * dy);
  return dist < pieceWidth / 3;
}

function joinGroups(p1, p2) {
  const oldGroup = p2.group;
  const newGroup = p1.group;
  if (oldGroup === newGroup) return;

  // Calculate offset between p1 and p2 in pieces coords
  const offsetX = p1.x - p2.x + (p1.gridX - p2.gridX) * pieceWidth;
  const offsetY = p1.y - p2.y + (p1.gridY - p2.gridY) * pieceHeight;

  // Reposition all pieces in old group relative to new group's position
  pieces.forEach(p => {
    if (p.group === oldGroup) {
      p.x += offsetX;
      p.y += offsetY;
      p.group = newGroup;
    }
  });
}

upload.addEventListener('change', e => {
  if (e.target.files.length === 0) return;
  const file = e.target.files[0];
  const reader = new FileReader();
  reader.onload = function(ev) {
    img = new Image();
    img.onload = function() {
      setupPuzzle();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

reset.addEventListener('click', () => {
  if (!img.complete || !img.naturalWidth) return;
  setupPuzzle();
});

window.addEventListener('resize', () => {
  resizeCanvas();
});

canvas.addEventListener('pointerdown', onPointerDown);
canvas.addEventListener('pointermove', onPointerMove);
canvas.addEventListener('pointerup', onPointerUp);
canvas.addEventListener('pointerleave', onPointerUp);
canvas.addEventListener('touchstart', onPointerDown);
canvas.addEventListener('touchmove', onPointerMove);
canvas.addEventListener('touchend', onPointerUp);

resizeCanvas();
</script>

</body>
</html>
